# -*- coding: utf-8 -*-
"""DatosGCA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1irhSMvU7yCBHRlvaKK-qWipDEnTJvg6V
"""

!pip install mplcursors

# Primero, asegúrate de instalar Folium si aún no lo has hecho
!pip install folium

import folium

# Crear un mapa centrado en Bogotá
bogota_lat = 4.611
bogota_lon = -74.081

m = folium.Map(location=[bogota_lat, bogota_lon], zoom_start=12)

# Añadir un marcador en Bogotá
folium.Marker(
    location=[bogota_lat, bogota_lon],
    popup='Bogotá',
    icon=folium.Icon(color='blue')
).add_to(m)

# Mostrar el mapa
m

pip install contextily

pip install geopandas matplotlib shapely numpy pytz mplcursors contextily

pip install geopandas matplotlib shapely numpy pytz mplcursors contextily

pip install --upgrade contextily

import os
import pytz
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
from shapely.geometry import Point
import contextily as ctx
import numpy as np
from datetime import datetime
import mplcursors

# Función para convertir coordenadas DMS a grados decimales
def dms_to_dd(coord):
    parts = coord[:-1].split('°')
    degrees = float(parts[0])
    minutes, seconds = map(float, parts[1].split("'"))
    dd = degrees + minutes / 60 + seconds / 3600
    return dd

# Obtener la fecha actual en Bogotá
def obtener_fecha_actual():
    zona_horaria_bogota = pytz.timezone('America/Bogota')
    fecha_actual_bogota = datetime.now(zona_horaria_bogota)
    return fecha_actual_bogota.strftime('%Y-%m-%d')

# Función para cargar los datos meteorológicos
def cargar_datos_meteorologicos():
    fecha_actual = obtener_fecha_actual()
    archivo_csv_meteorologicos = f'/content/drive/MyDrive/DatosCA/Datos_Meteorologicos_{fecha_actual}.csv'

    if os.path.exists(archivo_csv_meteorologicos):
        df_meteorologicos = pd.read_csv(archivo_csv_meteorologicos, sep=';')
        columnas_necesarias = ['name', 'Vel Viento', 'Temperatura', 'Dir Viento']
        for columna in columnas_necesarias:
            if columna not in df_meteorologicos.columns:
                print(f"La columna '{columna}' no se encuentra en el archivo.")
                return pd.DataFrame(columns=['name', 'Vel Viento', 'Temperatura', 'Dir Viento'])
        return df_meteorologicos[['name', 'Vel Viento', 'Temperatura', 'Dir Viento']]
    else:
        print(f"El archivo {archivo_csv_meteorologicos} no existe.")
        return pd.DataFrame(columns=['name', 'Vel Viento', 'Temperatura', 'Dir Viento'])

# Función para cargar los datos de calidad del aire
def cargar_datos_aire(contaminante):
    fecha_actual = obtener_fecha_actual()
    archivo_csv_aire = f'/content/drive/MyDrive/DatosCA/Datos_Aire_{fecha_actual}.csv'

    if os.path.exists(archivo_csv_aire):
        df_aire = pd.read_csv(archivo_csv_aire, sep=';')
        if contaminante in df_aire.columns:
            return df_aire[['name', contaminante]]
        else:
            print(f"El contaminante '{contaminante}' no se encuentra en el archivo.")
            return pd.DataFrame(columns=['name', contaminante])
    else:
        print(f"El archivo {archivo_csv_aire} no existe.")
        return pd.DataFrame(columns=['name', contaminante])

# Solicitar al usuario qué contaminante desea visualizar
contaminantes_disponibles = ['CO', 'NOX', 'BBP', 'SO2', 'NO', 'OZONO', 'BC', 'NO2', 'PM25', 'PM10']
contaminante_seleccionado = input(f"Seleccione el contaminante que desea visualizar ({', '.join(contaminantes_disponibles)}): ").upper()

# Cargar los datos de calidad del aire del contaminante seleccionado
df_aire = cargar_datos_aire(contaminante_seleccionado)

# Diccionario con las coordenadas de longitud y latitud en formato DMS
data = {
    'Nombre': ['Usaquen', 'Carvajal - Sevillana', 'Tunal', "Centro de Alto Rendimiento", "Las Ferias", "Guaymaral",
               "Kennedy", "Suba", "Puente Aranda", "MinAmbiente", "San Cristobal", "Movil 7ma", "Bolivia",
               "Fontibon", "Usme", "Jazmin", "Ciudad Bolivar", "Colina", "Movil Fontibon"],
    'Longitud': ["74°1'49.50\"", "74°8'54.90\"", "74°7'51.44\"", "74°5'2.28\"", "74°4'56.94\"", "74°2'39.06\"",
                 "74°9'40.80\"", "74° 5'36.46\"", "74°7'2.94\"", "74°4'1.13\"", "74°5'1.73\"", "74°5'2.28\"",
                 "74°7'33.18\"", "74°8'37.75\"", "74°7'1.7\"", "74°6'53.8\"", "74°9'58.6\"", "74°4'10.0\"",
                 "74°8'55.9\""],
    'Latitud': ["4°42'37.26\"", "4°35'44.22\"", "4°34'34.41\"", "4°39'30.48\"", "4°41'26.52\"", "4°47'1.52\"",
                "4°37'30.18\"", "4°45'40.49\"", "4°37'54.36\"", "4°37'31.75\"", "4°34'21.19\"", "4°38'32.75\"",
                "4°44'9.12\"", "4°40'41.67\"", "4°31'55.4\"", "4°36'30.6\"", "4°34'40.1\"", "4°44'14.1\"",
                "4°40'3.7\""]
}

# Convertir las coordenadas a grados decimales
data['Longitud'] = [dms_to_dd(coord) * -1 for coord in data['Longitud']]
data['Latitud'] = [dms_to_dd(coord) for coord in data['Latitud']]

# Convertir a GeoDataFrame
df = pd.DataFrame(data)
gdf = gpd.GeoDataFrame(
    df,
    geometry=[Point(xy) for xy in zip(df['Longitud'], df['Latitud'])],
    crs="EPSG:4326"
)

# Cargar datos meteorológicos
df_meteorologicos = cargar_datos_meteorologicos()

# Crear la figura y el eje
fig, ax = plt.subplots(figsize=(10, 6))

# Establecer límites del gráfico
ax.set_xlim([-74.25, -73.95])
ax.set_ylim([4.5, 4.85])

# Añadir el fondo del mapa con un estilo claro y ajustar la opacidad
ctx.add_basemap(ax, crs=gdf.crs.to_string(), source=ctx.providers.CartoDB.Positron, alpha=1)  # Puedes ajustar el valor de alpha aquí

# Plotear el GeoDataFrame
scatter = gdf.plot(ax=ax, color='red', markersize=0, label='Estaciones')

# Configurar los ejes
ax.set_xlabel('Longitud')
ax.set_ylabel('Latitud')
ax.set_title(f'Ubicación estaciones de monitoreo y niveles de {contaminante_seleccionado}')
ax.grid(True, linestyle='--', alpha=0.5)

# Definir longitud y distancia para los vectores de viento
longitud_vector_fija = 0.02  # Ajusta este valor según sea necesario
distancia_valor_contaminante = 0.2  # Valor fijo
radio_circulo = 0.012  # Aquí puedes ajustar el tamaño de los círculos

# Añadir etiquetas de contaminantes y vectores de viento
for i, row in gdf.iterrows():
    datos_estacion_aire = df_aire[df_aire['name'] == row['Nombre']]
    if not datos_estacion_aire.empty:
        valor_contaminante = datos_estacion_aire[contaminante_seleccionado].values[0]
        color_circulo = 'green' if valor_contaminante < 50 else 'yellow' if valor_contaminante < 100 else 'red'
        circle = plt.Circle((row.geometry.x, row.geometry.y), radio_circulo, color=color_circulo, fill=True, alpha=0.3)
        ax.add_artist(circle)

    datos_estacion_met = df_meteorologicos[df_meteorologicos['name'] == row['Nombre']]
    if not datos_estacion_met.empty:
        vel_viento = datos_estacion_met['Vel Viento'].values[0]
        dir_viento = datos_estacion_met['Dir Viento'].values[0]

        # Corrección para la dirección del viento
        if dir_viento > 360:
            dir_viento = dir_viento % 360
        elif dir_viento < 0:
            dir_viento = dir_viento + 360

        if dir_viento <= 360 and dir_viento != -9999 and vel_viento != -9999:
            angulo_radianes = np.deg2rad(dir_viento)
            dx = np.cos(angulo_radianes) * longitud_vector_fija
            dy = np.sin(angulo_radianes) * longitud_vector_fija
            ax.quiver(row.geometry.x, row.geometry.y, dx, dy, angles='xy', scale_units='xy', scale=1, color='black')

            if valor_contaminante >= 0 and valor_contaminante != -9999:
                ax.text(row.geometry.x - dx * distancia_valor_contaminante,
                        row.geometry.y - dy * distancia_valor_contaminante,
                        f'{valor_contaminante:.1f}', fontsize=8, color='black')
                ax.text(row.geometry.x + dx, row.geometry.y + dy,
                        f'{vel_viento} m/s', color='blue', fontsize=8, ha='center')

# Ajustar leyenda y mostrar el gráfico
ax.legend()
mplcursors.cursor(scatter, hover=True)
plt.show()

import os
import pytz
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
from shapely.geometry import Point
import contextily as ctx
import numpy as np
from datetime import datetime
import mplcursors

# Función para convertir coordenadas DMS a grados decimales
def dms_to_dd(coord):
    parts = coord[:-1].split('°')
    degrees = float(parts[0])
    minutes, seconds = map(float, parts[1].split("'"))
    dd = degrees + minutes / 60 + seconds / 3600
    return dd

# Obtener la fecha actual en Bogotá
def obtener_fecha_actual():
    zona_horaria_bogota = pytz.timezone('America/Bogota')
    fecha_actual_bogota = datetime.now(zona_horaria_bogota)
    return fecha_actual_bogota.strftime('%Y-%m-%d')

# Función para cargar los datos meteorológicos
def cargar_datos_meteorologicos(fecha):
    archivo_csv_meteorologicos = f'/content/drive/MyDrive/DatosCA/Datos_Meteorologicos_{fecha}.csv'

    if os.path.exists(archivo_csv_meteorologicos):
        df_meteorologicos = pd.read_csv(archivo_csv_meteorologicos, sep=';')
        columnas_necesarias = ['name', 'Vel Viento', 'Temperatura', 'Dir Viento']
        for columna in columnas_necesarias:
            if columna not in df_meteorologicos.columns:
                print(f"La columna '{columna}' no se encuentra en el archivo.")
                return pd.DataFrame(columns=['name', 'Vel Viento', 'Temperatura', 'Dir Viento'])
        return df_meteorologicos[['name', 'Vel Viento', 'Temperatura', 'Dir Viento']]
    else:
        print(f"El archivo {archivo_csv_meteorologicos} no existe.")
        return pd.DataFrame(columns=['name', 'Vel Viento', 'Temperatura', 'Dir Viento'])

# Función para cargar los datos de calidad del aire
def cargar_datos_aire(contaminante, fecha):
    archivo_csv_aire = f'/content/drive/MyDrive/DatosCA/Datos_Aire_{fecha}.csv'

    if os.path.exists(archivo_csv_aire):
        df_aire = pd.read_csv(archivo_csv_aire, sep=';')
        if contaminante in df_aire.columns:
            return df_aire[['name', contaminante]]
        else:
            print(f"El contaminante '{contaminante}' no se encuentra en el archivo.")
            return pd.DataFrame(columns=['name', contaminante])
    else:
        print(f"El archivo {archivo_csv_aire} no existe.")
        return pd.DataFrame(columns=['name', contaminante])

# Solicitar al usuario qué contaminante desea visualizar
contaminantes_disponibles = ['CO', 'NOX', 'BBP', 'SO2', 'NO', 'OZONO', 'BC', 'NO2', 'PM25', 'PM10']
contaminante_seleccionado = input(f"Seleccione el contaminante que desea visualizar ({', '.join(contaminantes_disponibles)}): ").upper()

# Solicitar la fecha para la cual el usuario quiere los datos
fecha_seleccionada = input("Ingrese la fecha para obtener los datos (formato: YYYY-MM-DD): ")

# Cargar los datos de calidad del aire y meteorológicos del contaminante seleccionado y la fecha elegida
df_aire = cargar_datos_aire(contaminante_seleccionado, fecha_seleccionada)
df_meteorologicos = cargar_datos_meteorologicos(fecha_seleccionada)

# Diccionario con las coordenadas de longitud y latitud en formato DMS
data = {
    'Nombre': ['Usaquen', 'Carvajal - Sevillana', 'Tunal', "Centro de Alto Rendimiento", "Las Ferias", "Guaymaral",
               "Kennedy", "Suba", "Puente Aranda", "MinAmbiente", "San Cristobal", "Movil 7ma", "Bolivia",
               "Fontibon", "Usme", "Jazmin", "Ciudad Bolivar", "Colina", "Movil Fontibon"],
    'Longitud': ["74°1'49.50\"", "74°8'54.90\"", "74°7'51.44\"", "74°5'2.28\"", "74°4'56.94\"", "74°2'39.06\"",
                 "74°9'40.80\"", "74° 5'36.46\"", "74°7'2.94\"", "74°4'1.13\"", "74°5'1.73\"", "74°5'2.28\"",
                 "74°7'33.18\"", "74°8'37.75\"", "74°7'1.7\"", "74°6'53.8\"", "74°9'58.6\"", "74°4'10.0\"",
                 "74°8'55.9\""],
    'Latitud': ["4°42'37.26\"", "4°35'44.22\"", "4°34'34.41\"", "4°39'30.48\"", "4°41'26.52\"", "4°47'1.52\"",
                "4°37'30.18\"", "4°45'40.49\"", "4°37'54.36\"", "4°37'31.75\"", "4°34'21.19\"", "4°38'32.75\"",
                "4°44'9.12\"", "4°40'41.67\"", "4°31'55.4\"", "4°36'30.6\"", "4°34'40.1\"", "4°44'14.1\"",
                "4°40'3.7\""]
}

# Convertir las coordenadas a grados decimales
data['Longitud'] = [dms_to_dd(coord) * -1 for coord in data['Longitud']]
data['Latitud'] = [dms_to_dd(coord) for coord in data['Latitud']]

# Convertir a GeoDataFrame
df = pd.DataFrame(data)
gdf = gpd.GeoDataFrame(
    df,
    geometry=[Point(xy) for xy in zip(df['Longitud'], df['Latitud'])],
    crs="EPSG:4326"
)

# Crear la carpeta donde se guardarán las imágenes si no existe
carpeta_imagenes = '/content/drive/MyDrive/DatosCA/Imagenes'
os.makedirs(carpeta_imagenes, exist_ok=True)

# Número de estaciones
num_estaciones = len(df)

# Definir la cantidad de registros por bloque (19 datos por hora)
registros_por_hora = 19

# Iterar sobre los bloques de datos
for i in range(0, len(df_meteorologicos), registros_por_hora):
    # Obtener el bloque de 19 registros
    df_hora = df_meteorologicos.iloc[i:i + registros_por_hora]
    hora = i // registros_por_hora + 1  # Número de la "hora" (bloque)

    # Crear la figura y el eje
    fig, ax = plt.subplots(figsize=(10, 6))

    # Establecer límites del gráfico
    ax.set_xlim([-74.25, -73.95])
    ax.set_ylim([4.5, 4.85])

    # Añadir el fondo del mapa con un estilo claro y ajustar la opacidad
    ctx.add_basemap(ax, crs=gdf.crs.to_string(), source=ctx.providers.CartoDB.Positron, alpha=1)

    # Plotear el GeoDataFrame
    scatter = gdf.plot(ax=ax, color='red', markersize=0, label='Estaciones')

    # Configurar los ejes
    ax.set_xlabel('Longitud')
    ax.set_ylabel('Latitud')
    ax.set_title(f'Ubicación estaciones de monitoreo y niveles de {contaminante_seleccionado} a las {hora}:00')
    ax.grid(True, linestyle='--', alpha=0.5)

    # Añadir etiquetas de contaminantes y vectores de viento
    for i, row in gdf.iterrows():
        datos_estacion_aire = df_aire[df_aire['name'] == row['Nombre']]
        if not datos_estacion_aire.empty:
            valor_contaminante = datos_estacion_aire[contaminante_seleccionado].values[0]
            color_circulo = 'green' if valor_contaminante < 50 else 'yellow' if valor_contaminante < 100 else 'red'
            circle = plt.Circle((row.geometry.x, row.geometry.y), 0.012, color=color_circulo, fill=True, alpha=0.3)
            ax.add_artist(circle)

        datos_estacion_met = df_hora[df_hora['name'] == row['Nombre']]
        if not datos_estacion_met.empty:
            vel_viento = datos_estacion_met['Vel Viento'].values[0]
            dir_viento = datos_estacion_met['Dir Viento'].values[0]

            # Corrección para la dirección del viento
            if dir_viento > 360:
                dir_viento = dir_viento % 360
            elif dir_viento < 0:
                dir_viento = dir_viento + 360

            if dir_viento <= 360 and dir_viento != -9999 and vel_viento != -9999:
                angulo_radianes = np.deg2rad(dir_viento)
                dx = np.cos(angulo_radianes) * 0.02
                dy = np.sin(angulo_radianes) * 0.02
                ax.quiver(row.geometry.x, row.geometry.y, dx, dy, angles='xy', scale_units='xy', scale=1, color='black')

                if valor_contaminante >= 0 and valor_contaminante != -9999:
                    ax.text(row.geometry.x - dx * 0.2,
                            row.geometry.y - dy * 0.2,
                            f'{valor_contaminante:.1f}', fontsize=8, color='black')
                    ax.text(row.geometry.x + dx, row.geometry.y + dy,
                            f'{vel_viento} m/s', color='blue', fontsize=8, ha='center')

    # Guardar la imagen de la hora
    nombre_imagen = f'{carpeta_imagenes}/Mapa_{fecha_seleccionada}_Hora{hora}.png'
    plt.savefig(nombre_imagen)
    plt.close()
    print(f'Imagen guardada: {nombre_imagen}')

!pip install flask flask-ngrok

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import requests
import time
import pytz
from datetime import datetime
import os

# Función para obtener y procesar los datos de una URL
def obtener_datos(url):
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        df = pd.read_json(data['TabularList'])
        df = df[['stationId', 'name', 'monitors']]

        # Obtener todas las claves únicas de los monitores
        all_keys = set()
        for monitors_list in df['monitors']:
            for monitor in monitors_list:
                all_keys.add(monitor['Name'])

        # Crear y rellenar un diccionario con los datos expandidos
        expanded_data = {key: [] for key in all_keys}
        expanded_data['stationId'] = df['stationId']
        expanded_data['name'] = df['name']

        for monitors_list in df['monitors']:
            row_dict = {key: float('nan') for key in all_keys}
            for monitor in monitors_list:
                row_dict[monitor['Name']] = monitor['value']
            for key in all_keys:
                expanded_data[key].append(row_dict[key])

        df_expanded = pd.DataFrame(expanded_data)

        df_expanded.rename(columns={
            'CO': 'CO', 'NO': 'NO', 'NO2': 'NO2', 'NOX': 'NOX',
            'OZONO': 'OZONO', 'PM10': 'PM10', 'PM25': 'PM25', 'SO2': 'SO2'
        }, inplace=True)

        zona_horaria_bogota = pytz.timezone('America/Bogota')
        fecha_actual_bogota = datetime.now(zona_horaria_bogota)
        df_expanded['Fecha'] = fecha_actual_bogota.strftime('%d-%m-%Y')
        df_expanded['Hora'] = fecha_actual_bogota.strftime('%H:%M')

        # Reorganizar columnas
        columns_order = ['Fecha', 'Hora', 'name', 'stationId'] + [
            col for col in df_expanded.columns if col not in ['Fecha', 'Hora', 'name', 'stationId']
        ]
        df_expanded = df_expanded[columns_order]

        return df_expanded
    else:
        print("Error al obtener los datos de", url, ". Código:", response.status_code)
        return None

# URLs
urls = [
    ("http://rmcab.ambientebogota.gov.co/dynamicTabulars/TabularReportTable?id=58", "Datos_Meteorológicos"),
    ("http://rmcab.ambientebogota.gov.co/dynamicTabulars/TabularReportTable?id=12", "Datos_Aire")
]

intervalo_segundos = 1800

while True:
    zona_horaria_bogota = pytz.timezone('America/Bogota')
    hora_actual_bogota = datetime.now(zona_horaria_bogota)
    fecha_actual = hora_actual_bogota.strftime('%Y-%m-%d')
    print("Hora actual:", hora_actual_bogota.strftime('%H:%M:%S'))

    from google.colab import drive
    drive.mount('/content/drive')
#     %cd /content/drive/MyDrive/DatosCA

    archivo_csv_aire = f'Datos_Aire_{fecha_actual}.csv'
    archivo_csv_meteorologicos = f'Datos_Meteorologicos_{fecha_actual}.csv'

    def agregar_datos_csv(df, archivo_csv):
        if os.path.exists(archivo_csv):
            df_existente = pd.read_csv(archivo_csv, sep=';')
            df_combinado = pd.concat([df_existente, df], ignore_index=True)
            df_combinado.to_csv(archivo_csv, sep=';', index=False)
        else:
            df.to_csv(archivo_csv, sep=';', index=False)

    for url, nombre_datos in urls:
        df_expanded = obtener_datos(url)
        if df_expanded is not None:
            if nombre_datos == "Datos_Aire":
                agregar_datos_csv(df_expanded, archivo_csv_aire)
            elif nombre_datos == "Datos_Meteorológicos":
                agregar_datos_csv(df_expanded, archivo_csv_meteorologicos)
            print(df_expanded)

    time.sleep(intervalo_segundos)

import os
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
import contextily as ctx
import numpy as np
from shapely.geometry import Point
from datetime import datetime
import imageio
import pytz

# Función para convertir coordenadas DMS a grados decimales
def dms_to_dd(coord):
    parts = coord[:-1].split('°')
    degrees = float(parts[0])
    minutes, seconds = map(float, parts[1].split("'"))
    dd = degrees + minutes / 60 + seconds / 3600
    return dd

# Coordenadas de las estaciones
estaciones_data = {
    'Nombre': ['Usaquen', 'Carvajal - Sevillana', 'Tunal', "Centro de Alto Rendimiento", "Las Ferias", "Guaymaral",
               "Kennedy", "Suba", "Puente Aranda", "MinAmbiente", "San Cristobal", "Movil 7ma", "Bolivia",
               "Fontibon", "Usme", "Jazmin", "Ciudad Bolivar", "Colina", "Movil Fontibon"],
    'Longitud': ["74°1'49.50\"", "74°8'54.90\"", "74°7'51.44\"", "74°5'2.28\"", "74°4'56.94\"", "74°2'39.06\"",
                 "74°9'40.80\"", "74° 5'36.46\"", "74°7'2.94\"", "74°4'1.13\"", "74°5'1.73\"", "74°5'2.28\"",
                 "74°7'33.18\"", "74°8'37.75\"", "74°7'1.7\"", "74°6'53.8\"", "74°9'58.6\"", "74°4'10.0\"",
                 "74°8'55.9\""],
    'Latitud': ["4°42'37.26\"", "4°35'44.22\"", "4°34'34.41\"", "4°39'30.48\"", "4°41'26.52\"", "4°47'1.52\"",
                "4°37'30.18\"", "4°45'40.49\"", "4°37'54.36\"", "4°37'31.75\"", "4°34'21.19\"", "4°38'32.75\"",
                "4°44'9.12\"", "4°40'41.67\"", "4°31'55.4\"", "4°36'30.6\"", "4°34'40.1\"", "4°44'14.1\"",
                "4°40'3.7\""]
}
estaciones_data['Longitud'] = [dms_to_dd(x) * -1 for x in estaciones_data['Longitud']]
estaciones_data['Latitud'] = [dms_to_dd(x) for x in estaciones_data['Latitud']]
gdf_estaciones = gpd.GeoDataFrame(estaciones_data, geometry=[Point(xy) for xy in zip(estaciones_data['Longitud'], estaciones_data['Latitud'])], crs='EPSG:4326')

# Pedir fecha
fecha_str = input("Ingrese la fecha (YYYY-MM-DD): ")

# Rutas de archivos
ruta_base = "/content/drive/MyDrive/DatosCA"
archivo_aire = os.path.join(ruta_base, f"Datos_Aire_{fecha_str}.csv")
archivo_met = os.path.join(ruta_base, f"Datos_Meteorologicos_{fecha_str}.csv")

# Verificar existencia
if not os.path.exists(archivo_aire):
    print(f"No existe el archivo de calidad del aire: {archivo_aire}")
elif not os.path.exists(archivo_met):
    print(f"No existe el archivo meteorológico: {archivo_met}")
else:
    # Leer datos
    df_aire = pd.read_csv(archivo_aire, sep=';')
    df_met = pd.read_csv(archivo_met, sep=';')

    # Mostrar contaminantes disponibles
    columnas_aire = df_aire.columns.tolist()
    posibles_contaminantes = [col for col in columnas_aire if col not in ['name', 'Hora']]
    print("\nContaminantes disponibles:")
    for cont in posibles_contaminantes:
        print(f" - {cont}")

    contaminante = input("\nIngrese el contaminante a graficar (como aparece arriba): ").strip().upper()

    # Filtrar horas válidas
    horas_disponibles = sorted(set(df_aire['Hora'].dropna().unique()))

    if len(horas_disponibles) == 0:
        print("No hay datos horarios disponibles.")
    else:
        # Crear carpeta temporal
        os.makedirs("frames_tmp", exist_ok=True)
        filenames = []

        for hora in horas_disponibles:
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.set_xlim([-74.25, -73.95])
            ax.set_ylim([4.5, 4.85])
            ctx.add_basemap(ax, crs=gdf_estaciones.crs.to_string(), source=ctx.providers.CartoDB.Positron, alpha=1)

            # Filtrar datos por hora
            df_hora = df_aire[df_aire['Hora'] == hora]
            df_met_hora = df_met[df_met['Hora'] == hora]

            # Graficar estaciones
            for i, row in gdf_estaciones.iterrows():
                nombre = row['Nombre']
                aire_val = df_hora[df_hora['name'] == nombre]
                met_val = df_met_hora[df_met_hora['name'] == nombre]

                if not aire_val.empty and contaminante in aire_val.columns:
                    val = aire_val[contaminante].values[0]
                    if pd.isna(val):
                        continue
                    color = 'green' if val < 50 else 'yellow' if val < 100 else 'red'
                    circle = plt.Circle((row.geometry.x, row.geometry.y), 0.012, color=color, alpha=0.4)
                    ax.add_patch(circle)

                if not met_val.empty:
                    vel = met_val['Vel Viento'].values[0]
                    dir_ = met_val['Dir Viento'].values[0]
                    if dir_ != -9999 and vel != -9999:
                        ang = np.deg2rad(dir_)
                        dx = np.cos(ang) * 0.02
                        dy = np.sin(ang) * 0.02
                        ax.quiver(row.geometry.x, row.geometry.y, dx, dy, angles='xy', scale_units='xy', scale=1, color='black')
                        ax.text(row.geometry.x + dx, row.geometry.y + dy, f"{vel:.1f} m/s", fontsize=6, color='blue')

            ax.set_title(f"{contaminante} - {hora}")
            filename = f"frames_tmp/{hora.replace(':', '-')}.png"
            fig.savefig(filename)
            filenames.append(filename)
            plt.close()

        print(f"\nSe generaron {len(filenames)} imagen(es).")

        # Mostrar resultado
        from IPython.display import Image, display
        if len(filenames) == 1:
            display(Image(filename=filenames[0]))
        else:
            gif_path = f"{ruta_base}/GIF_{contaminante}_{fecha_str}.gif"
            images = [imageio.imread(fname) for fname in filenames]
            imageio.mimsave(gif_path, images, fps=1)
            print(f"GIF guardado en: {gif_path}")
            display(Image(filename=gif_path))

        # Limpiar
        for f in filenames:
            os.remove(f)
        os.rmdir("frames_tmp")